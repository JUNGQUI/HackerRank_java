package com.jk.algorithm.hackerrank.problem.nonDivisibleSubSet;

/*
배열 s 가 주어지고 나누려고 하는 값 k 가 주어져 있을 때 s의 값들에 대해서 모든 인자끼리 중복되지 않게 합을 구해서 k 로 나눠지지 않는 요소들의 조합의 개수를 구하라.
또한 조합안의 모든 값은 서로 합했을 때 또한 k 로 나뉘어지면 안된다.

ex) s = {1, 7, 2, 4} | k = 3
1 + 7 = 8
1 + 2 = 3
1 + 4 = 5
7 + 2 = 9
7 + 4 = 11
2 + 4 = 6

8, 5, 11 의 경우에는 3으로 나눠지지 않는데, 이 조합들 중 하나가 1, 7 로 이루어져있다.
그와 동시에 7과 4도 가능한데, 1과 4도 가능하기 때문에 4 또한 subset 안에 들어 갈 수 있다.
(만약 4가 기존의 1과 허용되지 않았으면 1이 포함된 subset, 4가 포함된 subset 두 가지 case 로 변했을 것이다. 이 조건 때문에 무슨 말인지 이해가 안되서 한참 해맸음.)

k로 나누었을때 나머지가 없어야 함 -> 값 a + b 의 나머지는 있어야 함 -> (a+b)%k != 0 -> a%k + b%k != 0

=> subset 의 조합은 실제 값이 아닌 나머지로만 구성해도 문제 없으며 (개수를 구하기 때문) 항상 1/k-1, 2/k-2, 3/k-3... 과 같은 녀석을 제외한 모든 set의 조합이다.

따라서 모든 요소들을 k 로 나눈 나머지로 set을 만들고, 각 구성 중 k 를 기준으로 반대편 값의 개수와 비교해서 더 많은 개수를 더해주기만 하면 된다.

ex) S = [278,576,496,727,410,124,338,149,209,702,282,718,771,575,436], k = 7 일 경우 k로 나눈 나머지로 요소를 구한 map은

나머지가 1 인 element 의 개수 -> 2 개
나머지가 2 인 element 의 개수 -> 6 개
나머지가 4 인 element 의 개수 -> 2 개
나머지가 5 인 element 의 개수 -> 2 개
나머지가 6 인 element 의 개수 -> 3 개

k 는 7이기 때문에 1과 비교 값은 6이며 1은 2개, 6은 3개이므로 6을 나머지로 갖는 요소를 가져가는게 최대값에 가깝다. (3개)
2와 비교 값은 5, 2는 6개 5는 2개 이므로 2의 요소를 가져가야 한다 (6개)
3은 없지만 4가 있으므로 자동으로 4의 요소 개수를 가져간다 (2개)

따라서 두 개의 값의 합 중 k로 나뉘어지지 않는 size가 최대인 subset의 최대치는 11개이다.

단,
1. k가 정확하게 2로 나뉘어지는 경우 가운데 값이 나머지로 나온 값은 어떤 조합이든 1개만 들어갈 수 있기 때문에 해당 값은 제외해야 한다.
2. 마찬가지로 나머지가 0으로 들어가는 값은 배제가 아닌 1개만 들어가야 한다. (나머지가 1 + 0 일 경우 1이 남기 때문에 k 로 나누어지지 않기 때문, 당연히 이 상황에선 k가 1이 아니겠지)

 */