package com.jk.algorithm.hackerrank.problem.organizingContainersOfBalls;

/*
David 는 여러 container 를 가지고 있다. 각 container 에는 각기 다른 종류의 공이 들어 있다. (같은 종이 들어 있을 수 도 있다.)
n = 2 일 경우, 2가지 종류의 다른 공이 2가지의 container 에 들어 있다.
David 가 만족하는 container 의 모습은 하나의 container 에는 하나의 종류의 공만 있어야 한다.
container 를 정렬하는 방법은 서로 다른 종류의 container 에서 공을 교환 해야 하며, 공의 type 은 달라야 한다.

즉, 교환할 공은 서로 다른 종이여야 하며, 교환 시 일방적으로 공을 주거나 얹어주지 못한다. (1:1 교환)

교환 횟수는 제한이 없다.

교환하는 logic 은 각 container 에서 하나의 type 을 제외한 모든 개수가 0이여야 하고 교환 시 1:1 이기 때문에
각 container 가 가지고 있는 공의 개수와 type 별 공의 개수를 비교해서 동일하면 교환이 가능하다는 뜻이다.
ex)

  1 2 3
A 0 2 1 = 3
B 1 1 1 = 3
C 2 0 0 = 2
  3 3 2
A만 보자면
1만 가질 경우 - A2 와 C1을 교환, A3과 B1을 교환
  1 2 3
A 3 0 0 = 3
B 0 1 2 = 3
C 0 2 0 = 2
  3 3 2
이후 A 는 안정화 되었기 때문에 B3과 C2를 교환하면
A 3 0 0 = 3
B 0 3 0 = 3
C 0 0 2 = 2
  3 3 2

2만 가질 경우
  1 2 3
A 0 3 0 = 3
B 1 0 2 = 3
C 2 0 0 = 2
  3 3 2

  1 2 3
A 0 3 0 = 3
B 3 0 0 = 3
C 0 0 2 = 2
  3 3 2

하지만 A가 3만 가질 경우
  1 2 3
A 0 1 2 = 3
B 1 2 0 = 3
C 2 0 0 = 2
  3 3 2

  1 2 3
A 1 0 2 = 3
B 0 3 0 = 3
C 2 0 0 = 2
  3 3 2
이와 같은 상황이 일어난다.

1:1교환의 특성 상 최초 공의 개수에 맞는 개수의 type 만 가질 수 있기 때문에 A3만 가지는 case 는 존재 할 수 없다.
다만 A의 총 개수와 동일한 type 이 2가지 존재 하기 때문에 2가지 경우에는 A를 안정시킬 수 있다.

이러한 식으로 계산 할 경우
최초 서술하였듯 각 container 별 개수와 type 별 개수가 동일한지만 계산해보면 전체 array 를 정렬 할 수 있는지 파악 할 수 있다.

 */